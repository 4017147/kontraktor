<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>JS Test</title>
</head>
<p>

<h1>Kontraktor WebSocket Sample</h1>

    Server Time:<bR>
    <span id="time"></span>

<script>


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // fst-Json Helpers
    //

    /**
     * create wrapper object to make given list a valid fst-json Java Object array or Collection
     */
    function buildJList( list ) {
        list.splice( 0, 0, list.length ); // insert number of elements at 0
        return { styp: "array", seq: list };
    }

    /**
     * create wrapper object to make given list a valid fst-json Java Object
     */
    function buildJObject( type, obj ) {
        return { typ: type, obj: obj }
    }

    /**
     * makes a fst json serialized object more js-friendly
     * @param obj
     * @param preserveTypeAsAttribute - create a _typ property on each object denoting original java type
     * @param optionalTransformer - called as a map function for each object. if returns != null => replace given object in tree with result
     * @returns {*}
     */
    function transform(obj, preserveTypeAsAttribute, optionalTransformer) {
        if (optionalTransformer) {
            var trans = optionalTransformer.apply(null, [obj]);
            if (trans)
                return trans;
        }
        if (!obj)
            return obj;
        if (obj["styp"] && obj["seq"]) {
            var arr = transform(obj["seq"], preserveTypeAsAttribute, optionalTransformer);
            if (arr) {
                arr.shift();
                if (preserveTypeAsAttribute)
                    arr["_typ"] = obj["styp"];
            }
            return arr;
        }
        if (obj["typ"] && obj["obj"]) {
            if ('list' === obj['typ']) {
                // remove leading element length from arraylist
                obj["obj"].shift();
            }
            var res = transform(obj["obj"], preserveTypeAsAttribute, optionalTransformer);
            if (preserveTypeAsAttribute)
                res["_typ"] = obj["typ"];
            return res;
        }
        for (var property in obj) {
            if (obj.hasOwnProperty(property) && obj[property] != null) {
                if (obj[property].constructor == Object) {
                    obj[property] = transform(obj[property], preserveTypeAsAttribute, optionalTransformer);
                } else if (obj[property].constructor == Array) {
                    for (var i = 0; i < obj[property].length; i++) {
                        obj[property][i] = transform(obj[property][i], preserveTypeAsAttribute, optionalTransformer);
                    }
                }
            }
        }
        return obj;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    // actor remoting helper
    //

    /**
     * Minimalistic Promise class
     *
     * @param optional initialResult
     * @constructor
     */
    var Promise = function(initialResult) {
        var self = this;
        self.res = initialResult ? [initialResult,null] : null;
        self.cb = null;
        self.nextPromise = null;

        self._notify = function() {
            var res = self.cb.apply(null,self.res);
            self.cb = null;
            if ( res instanceof Promise ) {
                res.then(self.nextPromise);
            } else {
                self.nextPromise.complete(self.res[0],self.res[1]);
            }
        };

        self.then = function(cb) {
            if ( self.cb )
                throw "double callback registration on promise";
            if ( self.res ) {
                self._notify();
            }
            else
                self.cb = cb;
            self.nextPromise = new Promise();
            return self.nextPromise;
        };

        self.complete = function(r,e) {
            if ( self.res )
                throw "double completion on promise";
            self.res = [r,e];
            if ( self.cb ) {
                self._notify();
            }
        };
    };

    var Callback = function(resultsCallback) {
        if ( ! resultsCallback ) {
            throw "must register callback before sending";
        }
        var self = this;
        self.complete = resultsCallback;
    };

    var futureMap = {}; // future id => promise
    var currentSocket = { socket: null }; // use indirection to refer to a socket in order to ease reconnects
    var sbIdCount = 1;
    var sendSequence = 1;

    /**
     * A wrapper for a server side Actor
     */
    var KontrActor = function( socketHolder, id, optionalType ) {
        var self = this;

        self.id = id;
        self.type = optionalType ? optionalType : "untyped Actor";
        self.socketHolder = socketHolder;

        /**
         * create a sequenced batch of remote calls
         */
        function buildCallList( list, seqNo ) {
            var list1 = list.slice();
            list1.push(seqNo);
            return buildJList(list1);
        }

        /**
         *
         * @param callbackId - callback id in case method has a promise as a result
         * @param receiverKey - target actor id
         * @param args - [] of properly formatted fst-json JavaObjects
         * @returns {{typ, obj}|*}
         */
        function buildCall( callbackId, receiverKey, methodName, args ) {
            return buildJObject( "call", { futureKey: callbackId, queue: 0, method: methodName, receiverKey: receiverKey, args: buildJList(args) } );
        }

        function buildCallback( callbackId ) {
            return { "typ" : "cbw", "obj" : [ callbackId ] };
        }

        function mapCBObjects(argList) {
            for (var i = 0; i < argList.length; i++) {
                if (argList[i] instanceof Callback) {
                    var callbackId = sbIdCount++;
                    futureMap[callbackId] = argList[i];
                    argList[i] = buildCallback(callbackId);
                }
            }
        }

        /**
         * call an actor method returning a promise.
         *
         * "public IPromise myMethod( arg0, arg1, .. );"
         *
         */
        self.sendWithPromise = function( methodName, argList ) {
            if ( self.socketHolder.socket === null )
                throw "not connected";
            if ( ! argList )
                argList = [];
            mapCBObjects(argList);
            var futID = sbIdCount++;
            var cb = new Promise();
            futureMap[futID] = cb;
            var msg = buildCall( futID, self.id, methodName, argList );
            self.socketHolder.socket.send(JSON.stringify(buildCallList([msg],sendSequence++)));
            return cb;
        };

        /**
         * call a simple asynchronous method returning nothing
         *
         * "public void myMethod( arg0, arg1, .. );"
         *
         */
        self.send = function( methodName, argList ) {
            if ( self.socketHolder.socket === null )
                throw "not connected";
            if ( ! argList )
                argList = [];
            mapCBObjects(argList);
            var msg = buildCall( 0, self.id, methodName, argList );
            self.socketHolder.socket.send(JSON.stringify(buildCallList([msg],sendSequence++)));
            return self;
        };

    };

    /**
     * Websocket wrapper class. Only difference methods are used instead of properties for onmessage, onerror, ...
     *
     * onmessage parses messages received. If a promise response is received, the promise is invoked. If onmessage
     * receives unrecognized messages, these are passed through
     *
     * @param url
     * @param protocols
     * @constructor
     */
    var KontraktorSocket = function( url, protocols ) {
        var self = this;

        var incomingMessages = [];
        var inParse = false;

        self.automaticTransformResults = true;

        if ( protocols )
            self.socket = new WebSocket(url,protocols);
        else
            self.socket = new WebSocket(url);

        self.close = function( code, reaseon ) {
            self.socket.close(code,reaseon);
        };

        self.send = function( data ) {
            self.socket.send(data);
        };

        self.onclose = function( eventListener ) {
            self.socket.onclose = eventListener;
        };

        self.onmessage = function( eventListener ) {
            self.socket.onmessage = function( message ) {
                if (typeof message.data == 'string') {
                    eventListener.apply(self,[message]);
                } else {
                    incomingMessages.push(message.data);
                    // parse messages ordered
                    var parse = function() {
                        var fr = new FileReader();
                        fr.onabort = function(error) {
                            if ( self.socket.onerror )
                                self.socket.onerror.apply(self,[error]);
                            else {
                                console.log("unhandled transmission error: "+error);
                            }
                            if ( incomingMessages.length > 0 )
                                parse.apply();
                            else
                                inParse = false;
                        };
                        fr.onerror = fr.onabort;
                        fr.onloadend = function (event) {
                            try {
                                var blob = event.target.result;
                                var response = JSON.parse(blob);
                                var respLen = response.seq[0]-1; // last one is sequence. FIXME: should do sequence check here
                                for ( var i = 0; i < respLen; i++ ) {
                                    var resp = response.seq[i + 1];
                                    if ( ! resp.obj.method && resp.obj.receiverKey ) { // => callback
                                        var cb = futureMap[resp.obj.receiverKey];
                                        if ( ! cb ) {
                                            console.error("unhandled callback "+JSON.stringify(resp,null,2));
                                        } else {
                                            if ( cb instanceof Promise || (cb instanceof Callback && resp.obj.args.seq[2] !== 'CNT') )
                                                delete futureMap[resp.obj.receiverKey];
                                            if ( self.automaticTransformResults ) {
                                                var transFun = function( obj ) {
                                                    if ( obj != null && obj instanceof Array && obj.length == 2 && typeof obj[1] === 'string' && obj[1].indexOf("_ActorProxy") > 0 ) {
                                                        return new KontrActor( currentSocket, obj[0], obj[1] );
                                                    }
                                                    return null;
                                                };
                                                cb.complete( transform(resp.obj.args.seq[1], true, transFun), transform(resp.obj.args.seq[2], transFun ) ); // promise.complete(result, error)
                                            } else
                                                cb.complete( resp.obj.args.seq[1], resp.obj.args.seq[2] ); // promise.complete(result, error)
                                        }
                                    } else {
                                        eventListener.apply(self, [resp]);
                                    }
                                }
                            } catch (err) {
                                console.error("unhandled decoding error:"+err)
                                if ( self.socket.onerror )
                                    self.socket.onerror.apply(self,[err]);
                            }
                            if ( incomingMessages.length > 0 )
                                parse.apply();
                            else
                                inParse = false;
                        };
                        fr.readAsBinaryString(incomingMessages.shift());
                    };
                    if ( ! inParse ) {
                        inParse = true;
                        parse.apply();
                    }
                }
            }
        };

        self.onerror = function( eventListener ) {
            self.socket.onerror = eventListener;
        };

        self.onopen = function( eventListener ) {
            self.socket.onopen = function(ev) {
                setTimeout( function() {
                    eventListener.apply(self.socket,[ev])
                },500);
            };
        };

    };

    ////////////////////////// TESTING /////////////////////////

    var socket = new KontraktorSocket("ws://localhost:8080/ws");
    currentSocket.socket = socket;

    var MyHttpApp = new KontrActor(currentSocket,1,"MyHttpApp");

    socket.onmessage( function(message) {
        if (typeof message === MessageEvent ) {
            console.error("unexpected message:"+message.data);
        } else {
            console.log(JSON.stringify(message, null, 2));
            console.log(JSON.stringify(transform(message), null, 2));
        }
    });

    socket.onerror( function(err) {
        console.log(err);
    });

    socket.onclose( function() {
        console.log("close");
    });

    socket.onopen( function (event) {
        MyHttpApp.sendWithPromise("login", [ "clientuser", "clientpwd" ])
        .then( function(mySession,err) {
            if ( err )
                console.log(err);
            else {

                mySession.sendWithPromise("getToDo")
                .then( function( res,err ) {
                    if ( err )
                        console.log(err);
                    console.log(res);
                });

                MyHttpApp.sendWithPromise("getServerTime")
                .then( function( res,err ) {
                    if ( err )
                        console.log(err);
                    console.log(res);
                });

                mySession.send( "streamToDo", [
                    "p", // filter
                    new Callback( function( res, err ) {
                        if ( err === 'CNT' )
                            console.log("streamed:"+res);
                        else
                            console.log("streamed closed "+err);
                    })
                ]);

                mySession.send( "subscribe", [ new Callback(function(e,r) {
                    var tim = document.getElementById("time");
                    tim.innerHTML=e;
                    var bright = 1.0;

                    // fadeout bgcolor
                    var fun = function () {
                        tim.style.backgroundColor = "rgba(255,200,100," + bright + ")";
                        bright -= .03;
                        if (bright >= 0.0) {
                            setTimeout(fun,50);
                        }
                    };
                    fun.apply(null,[]);
                })])

            }
        });
    });

</script>
</body>
</html>