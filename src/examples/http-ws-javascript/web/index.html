<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>JS Test</title>
</head>
<body>

<h1>Kontraktor Http Sample</h1>

<script>


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // fst-Json Helpers
    //

    /**
     * create wrapper object to make given list a valid fst-json Java Object array or Collection
     */
    function buildJList( list ) {
        list.splice( 0, 0, list.length ); // insert number of elements at 0
        return { styp: "array", seq: list };
    }

    /**
     * create wrapper object to make given list a valid fst-json Java Object
     */
    function buildJObject( type, obj ) {
        return { typ: type, obj: obj }
    }

    /**
     * makes a fst json serialized object more js-friendly
     * @param obj
     * @param preserveTypeAsAttribute - create a _typ property on each object denoting original java type
     * @param optionalTransformer - called as a map function for each object. if returns != null => replace given object in tree with result
     * @returns {*}
     */
    function transform(obj, preserveTypeAsAttribute, optionalTransformer) {
        if ( optionalTransformer ) {
            var trans = optionalTransformer.apply(null,[obj]);
            if ( trans )
                return trans;
        }
        if ( ! obj )
            return obj;
        if ( obj["styp"] && obj["seq"] ) {
            var arr = transform(obj["seq"], preserveTypeAsAttribute, optionalTransformer );
            if ( arr ) {
                arr.shift();
                if ( preserveTypeAsAttribute )
                    arr["_typ"] = obj["styp"];
            }
            return arr;
        }
        if ( obj["typ"] && obj["obj"] ) {
            if ( 'list' === obj['typ']) {
                // remove leading element length from arraylist
                obj["obj"].shift();
            }
            var res = transform( obj["obj"], preserveTypeAsAttribute, optionalTransformer  );
            if ( preserveTypeAsAttribute )
                res["_typ"] = obj["typ"];
            return res;
        }
        for (var property in obj) {
            if (obj.hasOwnProperty(property) && obj[property] != null) {
                if (obj[property].constructor == Object) {
                    obj[property] = transform(obj[property], preserveTypeAsAttribute, optionalTransformer );
                } else if (obj[property].constructor == Array) {
                    for (var i = 0; i < obj[property].length; i++) {
                        obj[property][i] = transform(obj[property][i], preserveTypeAsAttribute, optionalTransformer );
                    }
                }
            }
        }
        return obj;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////
    //
    // actor remoting helper
    //

    /**
     * Minimalistic Promise class
     *
     * @param optional initialResult
     * @constructor
     */
    var Promise = function(initialResult) {
        var self = this;
        self.res = initialResult ? [initialResult,null] : null;
        self.isPromise = false;
        self.cb = null;
        self.isCompleted = false;
        self.nextPromise = null;

        // private
        self._notifyCB = function() {
            var res = self.cb.apply(self.cb,self.res);
            if ( self.nextPromise ) {
                if ( res instanceof Promise ) {
                    res.then(self.nextPromise);
                } else {
                    self.nextPromise.complete(self.res[0],self.res[1]);
                }
            }
            self.cb = null;
        };

        self.then = function(cb) {
            if ( self.cb != null )
                throw "only one callback can be set on promise";
            self.nextPromise = new Promise();
            self.cb = cb;
            if ( self.isCompleted )
                self._notifyCB();
        };
        self.complete = function(r,e) {
            if ( self.isCompleted )
                throw "double completion on promise";
            self.res = [r,e];
            self.isCompleted = true;
            if ( self.isCompleted )
                self._notifyCB();
        };
    };


    var futureMap = {}; // future id => promise
    var currentSocket = { socket: null }; // use indirection to refer to a socket in order to ease reconnects
    var sbIdCount = 1;
    var sendSequence = 1;

    var KontrActor = function( socketHolder, id, optionalType ) {
        var self = this;

        self.id = id;
        self.type = optionalType ? optionalType : "untyped Actor";
        self.socketHolder = socketHolder;

        /**
         * create a sequenced batch of remote calls
         */
        function buildCallList( list, seqNo ) {
            var list1 = list.slice();
            list1.push(seqNo);
            return buildJList(list1);
        }

        /**
         *
         * @param callbackId - callback id in case method has a promise as a result
         * @param receiverKey - target actor id
         * @param args - [] of properly formatted fst-json JavaObjects
         * @returns {{typ, obj}|*}
         */
        function buildCall( callbackId, receiverKey, methodName, args ) {
            return buildJObject( "call", { futureKey: callbackId, queue: 0, method: methodName, receiverKey: receiverKey, args: buildJList(args) } );
        }

        self.send = function( methodName, argList ) {
            if ( self.socketHolder.socket === null )
                throw "not connected";
            if ( ! argList )
                argList = [];
            var futID = sbIdCount++;
            var cb = new Promise();
            futureMap[futID] = cb;
            var msg = buildCall( futID, self.id, methodName, argList );
            self.socketHolder.socket.send(JSON.stringify(buildCallList([msg],sendSequence++)));
            return cb;
        };

    };

    /**
     * Websocket wrapper class. Only difference methods are used instead of properties for onmessage, onerror, ...
     *
     * onmessage parses messages received. If a promise response is received, the promise is invoked. If onmessage
     * receives unrecognized messages, these are passed through
     *
     * @param url
     * @param protocols
     * @constructor
     */
    var KontraktorSocket = function( url, protocols ) {
        var self = this;

        var incomingMessages = [];
        var inParse = false;

        self.automaticTransformResults = true;

        if ( protocols )
            self.socket = new WebSocket(url,protocols);
        else
            self.socket = new WebSocket(url);

        self.close = function( code, reaseon ) {
            self.socket.close(code,reaseon);
        };

        self.send = function( data ) {
            self.socket.send(data);
        };

        self.onclose = function( eventListener ) {
            self.socket.onclose = eventListener;
        };

        self.onmessage = function( eventListener ) {
            self.socket.onmessage = function( message ) {
                if (typeof message.data == 'string') {
                    eventListener.apply(self,[message]);
                } else {
                    incomingMessages.push(message.data);
                    // parse messages ordered
                    var parse = function() {
                        var fr = new FileReader();
                        fr.onabort = function(error) {
                            if ( self.socket.onerror )
                                self.socket.onerror.apply(self,[error]);
                            else {
                                console.log("unhandled transmission error: "+error);
                            }
                            if ( incomingMessages.length > 0 )
                                parse.apply();
                            else
                                inParse = false;
                        };
                        fr.onerror = fr.onabort;
                        fr.onloadend = function (event) {
                            try {
                                var blob = event.target.result;
                                var response = JSON.parse(blob);
                                var respLen = response.seq[0]-1; // last one is sequence. FIXME: should do sequence check here
                                for ( var i = 0; i < respLen; i++ ) {
                                    var resp = response.seq[i + 1];
                                    if ( ! resp.obj.method && resp.obj.receiverKey ) { // => callback
                                        var cb = futureMap[resp.obj.receiverKey];
                                        if ( ! cb ) {
                                            console.error("unhandled callback "+JSON.stringify(resp,null,2));
                                        } else {
                                            delete futureMap[resp.obj.receiverKey];
                                            if ( self.automaticTransformResults ) {
                                                var transFun = function( obj ) {
                                                    if ( obj != null && obj instanceof Array && obj.length == 2 && typeof obj[1] === 'string' && obj[1].indexOf("_ActorProxy") > 0 ) {
                                                        return new KontrActor( currentSocket, obj[0], obj[1] );
                                                    }
                                                    return null;
                                                };
                                                cb.complete( transform(resp.obj.args.seq[1], true, transFun), transform(resp.obj.args.seq[2], transFun ) ); // promise.complete(result, error)
                                            } else
                                                cb.complete( resp.obj.args.seq[1], resp.obj.args.seq[2] ); // promise.complete(result, error)
                                        }
                                    } else {
                                        eventListener.apply(self, [resp]);
                                    }
                                }
                            } catch (err) {
                                console.error("unhandled decoding error:"+err)
                                if ( self.socket.onerror )
                                    self.socket.onerror.apply(self,[err]);
                            }
                            if ( incomingMessages.length > 0 )
                                parse.apply();
                            else
                                inParse = false;
                        };
                        fr.readAsBinaryString(incomingMessages.shift());
                    };
                    if ( ! inParse ) {
                        inParse = true;
                        parse.apply();
                    }
                }
            }
        };

        self.onerror = function( eventListener ) {
            self.socket.onerror = eventListener;
        };

        self.onopen = function( eventListener ) {
            self.socket.onopen = function(ev) {
                setTimeout( function() {
                    eventListener.apply(self.socket,[ev])
                },100);
            };
        };

    };



    ////////////////////////// TESTING /////////////////////////

    var socket = new KontraktorSocket("ws://localhost:8080/ws");
    currentSocket.socket = socket;

    var MyHttpApp = new KontrActor(currentSocket,1,"MyHttpApp");

    socket.onmessage( function(message) {
        if (typeof message === MessageEvent ) {
            console.error("unexpected message:"+message.data);
        } else {
            console.log(JSON.stringify(message, null, 2));
            console.log(JSON.stringify(transform(message), null, 2));
        }
    });

    socket.onerror( function(err) {
        console.log(err);
    });

    socket.onclose( function() {
        console.log("close");
    });

    socket.onopen( function (event) {
        MyHttpApp.send("login", [ "clientuser", "clientpwd" ])
                .then( function(mySession,err) {
                    if ( err )
                        console.log(err);
                    else {
                        mySession.send("getToDo")
                                .then( function( res,err ) {
                                    console.log(res);
                                });
                        MyHttpApp.send("getServerTime")
                                .then( function( res,err ) {
                                    if ( err )
                                        console.log(err);
                                    console.log(res);
                                })
                    }
                });
    });

</script>
</body>
</html>